// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i PWZ1.0/internal/storage.Storage -o storage_mock.go -n StorageMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"PWZ1.0/internal/models"
	"github.com/gojuno/minimock/v3"
	"github.com/jackc/pgx/v5"
)

// StorageMock implements mm_storage.Storage
type StorageMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDeleteOrder          func(ctx context.Context, id uint64) (err error)
	funcDeleteOrderOrigin    string
	inspectFuncDeleteOrder   func(ctx context.Context, id uint64)
	afterDeleteOrderCounter  uint64
	beforeDeleteOrderCounter uint64
	DeleteOrderMock          mStorageMockDeleteOrder

	funcGetHistory          func(ctx context.Context, page uint32, count uint32) (oa1 []models.OrderHistory, err error)
	funcGetHistoryOrigin    string
	inspectFuncGetHistory   func(ctx context.Context, page uint32, count uint32)
	afterGetHistoryCounter  uint64
	beforeGetHistoryCounter uint64
	GetHistoryMock          mStorageMockGetHistory

	funcGetOrder          func(ctx context.Context, id uint64) (o1 models.Order, err error)
	funcGetOrderOrigin    string
	inspectFuncGetOrder   func(ctx context.Context, id uint64)
	afterGetOrderCounter  uint64
	beforeGetOrderCounter uint64
	GetOrderMock          mStorageMockGetOrder

	funcListOrders          func(ctx context.Context) (oa1 []models.Order, err error)
	funcListOrdersOrigin    string
	inspectFuncListOrders   func(ctx context.Context)
	afterListOrdersCounter  uint64
	beforeListOrdersCounter uint64
	ListOrdersMock          mStorageMockListOrders

	funcSaveOrderTx          func(ctx context.Context, tx pgx.Tx, order models.Order) (err error)
	funcSaveOrderTxOrigin    string
	inspectFuncSaveOrderTx   func(ctx context.Context, tx pgx.Tx, order models.Order)
	afterSaveOrderTxCounter  uint64
	beforeSaveOrderTxCounter uint64
	SaveOrderTxMock          mStorageMockSaveOrderTx

	funcUpdateOrderTx          func(ctx context.Context, tx pgx.Tx, order models.Order) (err error)
	funcUpdateOrderTxOrigin    string
	inspectFuncUpdateOrderTx   func(ctx context.Context, tx pgx.Tx, order models.Order)
	afterUpdateOrderTxCounter  uint64
	beforeUpdateOrderTxCounter uint64
	UpdateOrderTxMock          mStorageMockUpdateOrderTx

	funcWithTransaction          func(ctx context.Context, fn func(ctx context.Context, tx pgx.Tx) error) (err error)
	funcWithTransactionOrigin    string
	inspectFuncWithTransaction   func(ctx context.Context, fn func(ctx context.Context, tx pgx.Tx) error)
	afterWithTransactionCounter  uint64
	beforeWithTransactionCounter uint64
	WithTransactionMock          mStorageMockWithTransaction
}

// NewStorageMock returns a mock for mm_storage.Storage
func NewStorageMock(t minimock.Tester) *StorageMock {
	m := &StorageMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DeleteOrderMock = mStorageMockDeleteOrder{mock: m}
	m.DeleteOrderMock.callArgs = []*StorageMockDeleteOrderParams{}

	m.GetHistoryMock = mStorageMockGetHistory{mock: m}
	m.GetHistoryMock.callArgs = []*StorageMockGetHistoryParams{}

	m.GetOrderMock = mStorageMockGetOrder{mock: m}
	m.GetOrderMock.callArgs = []*StorageMockGetOrderParams{}

	m.ListOrdersMock = mStorageMockListOrders{mock: m}
	m.ListOrdersMock.callArgs = []*StorageMockListOrdersParams{}

	m.SaveOrderTxMock = mStorageMockSaveOrderTx{mock: m}
	m.SaveOrderTxMock.callArgs = []*StorageMockSaveOrderTxParams{}

	m.UpdateOrderTxMock = mStorageMockUpdateOrderTx{mock: m}
	m.UpdateOrderTxMock.callArgs = []*StorageMockUpdateOrderTxParams{}

	m.WithTransactionMock = mStorageMockWithTransaction{mock: m}
	m.WithTransactionMock.callArgs = []*StorageMockWithTransactionParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStorageMockDeleteOrder struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockDeleteOrderExpectation
	expectations       []*StorageMockDeleteOrderExpectation

	callArgs []*StorageMockDeleteOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockDeleteOrderExpectation specifies expectation struct of the Storage.DeleteOrder
type StorageMockDeleteOrderExpectation struct {
	mock               *StorageMock
	params             *StorageMockDeleteOrderParams
	paramPtrs          *StorageMockDeleteOrderParamPtrs
	expectationOrigins StorageMockDeleteOrderExpectationOrigins
	results            *StorageMockDeleteOrderResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockDeleteOrderParams contains parameters of the Storage.DeleteOrder
type StorageMockDeleteOrderParams struct {
	ctx context.Context
	id  uint64
}

// StorageMockDeleteOrderParamPtrs contains pointers to parameters of the Storage.DeleteOrder
type StorageMockDeleteOrderParamPtrs struct {
	ctx *context.Context
	id  *uint64
}

// StorageMockDeleteOrderResults contains results of the Storage.DeleteOrder
type StorageMockDeleteOrderResults struct {
	err error
}

// StorageMockDeleteOrderOrigins contains origins of expectations of the Storage.DeleteOrder
type StorageMockDeleteOrderExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteOrder *mStorageMockDeleteOrder) Optional() *mStorageMockDeleteOrder {
	mmDeleteOrder.optional = true
	return mmDeleteOrder
}

// Expect sets up expected params for Storage.DeleteOrder
func (mmDeleteOrder *mStorageMockDeleteOrder) Expect(ctx context.Context, id uint64) *mStorageMockDeleteOrder {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("StorageMock.DeleteOrder mock is already set by Set")
	}

	if mmDeleteOrder.defaultExpectation == nil {
		mmDeleteOrder.defaultExpectation = &StorageMockDeleteOrderExpectation{}
	}

	if mmDeleteOrder.defaultExpectation.paramPtrs != nil {
		mmDeleteOrder.mock.t.Fatalf("StorageMock.DeleteOrder mock is already set by ExpectParams functions")
	}

	mmDeleteOrder.defaultExpectation.params = &StorageMockDeleteOrderParams{ctx, id}
	mmDeleteOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteOrder.expectations {
		if minimock.Equal(e.params, mmDeleteOrder.defaultExpectation.params) {
			mmDeleteOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteOrder.defaultExpectation.params)
		}
	}

	return mmDeleteOrder
}

// ExpectCtxParam1 sets up expected param ctx for Storage.DeleteOrder
func (mmDeleteOrder *mStorageMockDeleteOrder) ExpectCtxParam1(ctx context.Context) *mStorageMockDeleteOrder {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("StorageMock.DeleteOrder mock is already set by Set")
	}

	if mmDeleteOrder.defaultExpectation == nil {
		mmDeleteOrder.defaultExpectation = &StorageMockDeleteOrderExpectation{}
	}

	if mmDeleteOrder.defaultExpectation.params != nil {
		mmDeleteOrder.mock.t.Fatalf("StorageMock.DeleteOrder mock is already set by Expect")
	}

	if mmDeleteOrder.defaultExpectation.paramPtrs == nil {
		mmDeleteOrder.defaultExpectation.paramPtrs = &StorageMockDeleteOrderParamPtrs{}
	}
	mmDeleteOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteOrder
}

// ExpectIdParam2 sets up expected param id for Storage.DeleteOrder
func (mmDeleteOrder *mStorageMockDeleteOrder) ExpectIdParam2(id uint64) *mStorageMockDeleteOrder {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("StorageMock.DeleteOrder mock is already set by Set")
	}

	if mmDeleteOrder.defaultExpectation == nil {
		mmDeleteOrder.defaultExpectation = &StorageMockDeleteOrderExpectation{}
	}

	if mmDeleteOrder.defaultExpectation.params != nil {
		mmDeleteOrder.mock.t.Fatalf("StorageMock.DeleteOrder mock is already set by Expect")
	}

	if mmDeleteOrder.defaultExpectation.paramPtrs == nil {
		mmDeleteOrder.defaultExpectation.paramPtrs = &StorageMockDeleteOrderParamPtrs{}
	}
	mmDeleteOrder.defaultExpectation.paramPtrs.id = &id
	mmDeleteOrder.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteOrder
}

// Inspect accepts an inspector function that has same arguments as the Storage.DeleteOrder
func (mmDeleteOrder *mStorageMockDeleteOrder) Inspect(f func(ctx context.Context, id uint64)) *mStorageMockDeleteOrder {
	if mmDeleteOrder.mock.inspectFuncDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("Inspect function is already set for StorageMock.DeleteOrder")
	}

	mmDeleteOrder.mock.inspectFuncDeleteOrder = f

	return mmDeleteOrder
}

// Return sets up results that will be returned by Storage.DeleteOrder
func (mmDeleteOrder *mStorageMockDeleteOrder) Return(err error) *StorageMock {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("StorageMock.DeleteOrder mock is already set by Set")
	}

	if mmDeleteOrder.defaultExpectation == nil {
		mmDeleteOrder.defaultExpectation = &StorageMockDeleteOrderExpectation{mock: mmDeleteOrder.mock}
	}
	mmDeleteOrder.defaultExpectation.results = &StorageMockDeleteOrderResults{err}
	mmDeleteOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteOrder.mock
}

// Set uses given function f to mock the Storage.DeleteOrder method
func (mmDeleteOrder *mStorageMockDeleteOrder) Set(f func(ctx context.Context, id uint64) (err error)) *StorageMock {
	if mmDeleteOrder.defaultExpectation != nil {
		mmDeleteOrder.mock.t.Fatalf("Default expectation is already set for the Storage.DeleteOrder method")
	}

	if len(mmDeleteOrder.expectations) > 0 {
		mmDeleteOrder.mock.t.Fatalf("Some expectations are already set for the Storage.DeleteOrder method")
	}

	mmDeleteOrder.mock.funcDeleteOrder = f
	mmDeleteOrder.mock.funcDeleteOrderOrigin = minimock.CallerInfo(1)
	return mmDeleteOrder.mock
}

// When sets expectation for the Storage.DeleteOrder which will trigger the result defined by the following
// Then helper
func (mmDeleteOrder *mStorageMockDeleteOrder) When(ctx context.Context, id uint64) *StorageMockDeleteOrderExpectation {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("StorageMock.DeleteOrder mock is already set by Set")
	}

	expectation := &StorageMockDeleteOrderExpectation{
		mock:               mmDeleteOrder.mock,
		params:             &StorageMockDeleteOrderParams{ctx, id},
		expectationOrigins: StorageMockDeleteOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteOrder.expectations = append(mmDeleteOrder.expectations, expectation)
	return expectation
}

// Then sets up Storage.DeleteOrder return parameters for the expectation previously defined by the When method
func (e *StorageMockDeleteOrderExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockDeleteOrderResults{err}
	return e.mock
}

// Times sets number of times Storage.DeleteOrder should be invoked
func (mmDeleteOrder *mStorageMockDeleteOrder) Times(n uint64) *mStorageMockDeleteOrder {
	if n == 0 {
		mmDeleteOrder.mock.t.Fatalf("Times of StorageMock.DeleteOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteOrder.expectedInvocations, n)
	mmDeleteOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteOrder
}

func (mmDeleteOrder *mStorageMockDeleteOrder) invocationsDone() bool {
	if len(mmDeleteOrder.expectations) == 0 && mmDeleteOrder.defaultExpectation == nil && mmDeleteOrder.mock.funcDeleteOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteOrder.mock.afterDeleteOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteOrder implements mm_storage.Storage
func (mmDeleteOrder *StorageMock) DeleteOrder(ctx context.Context, id uint64) (err error) {
	mm_atomic.AddUint64(&mmDeleteOrder.beforeDeleteOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteOrder.afterDeleteOrderCounter, 1)

	mmDeleteOrder.t.Helper()

	if mmDeleteOrder.inspectFuncDeleteOrder != nil {
		mmDeleteOrder.inspectFuncDeleteOrder(ctx, id)
	}

	mm_params := StorageMockDeleteOrderParams{ctx, id}

	// Record call args
	mmDeleteOrder.DeleteOrderMock.mutex.Lock()
	mmDeleteOrder.DeleteOrderMock.callArgs = append(mmDeleteOrder.DeleteOrderMock.callArgs, &mm_params)
	mmDeleteOrder.DeleteOrderMock.mutex.Unlock()

	for _, e := range mmDeleteOrder.DeleteOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteOrder.DeleteOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteOrder.DeleteOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteOrder.DeleteOrderMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteOrder.DeleteOrderMock.defaultExpectation.paramPtrs

		mm_got := StorageMockDeleteOrderParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteOrder.t.Errorf("StorageMock.DeleteOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteOrder.DeleteOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteOrder.t.Errorf("StorageMock.DeleteOrder got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteOrder.DeleteOrderMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteOrder.t.Errorf("StorageMock.DeleteOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteOrder.DeleteOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteOrder.DeleteOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteOrder.t.Fatal("No results are set for the StorageMock.DeleteOrder")
		}
		return (*mm_results).err
	}
	if mmDeleteOrder.funcDeleteOrder != nil {
		return mmDeleteOrder.funcDeleteOrder(ctx, id)
	}
	mmDeleteOrder.t.Fatalf("Unexpected call to StorageMock.DeleteOrder. %v %v", ctx, id)
	return
}

// DeleteOrderAfterCounter returns a count of finished StorageMock.DeleteOrder invocations
func (mmDeleteOrder *StorageMock) DeleteOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteOrder.afterDeleteOrderCounter)
}

// DeleteOrderBeforeCounter returns a count of StorageMock.DeleteOrder invocations
func (mmDeleteOrder *StorageMock) DeleteOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteOrder.beforeDeleteOrderCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.DeleteOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteOrder *mStorageMockDeleteOrder) Calls() []*StorageMockDeleteOrderParams {
	mmDeleteOrder.mutex.RLock()

	argCopy := make([]*StorageMockDeleteOrderParams, len(mmDeleteOrder.callArgs))
	copy(argCopy, mmDeleteOrder.callArgs)

	mmDeleteOrder.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteOrderDone returns true if the count of the DeleteOrder invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockDeleteOrderDone() bool {
	if m.DeleteOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteOrderMock.invocationsDone()
}

// MinimockDeleteOrderInspect logs each unmet expectation
func (m *StorageMock) MinimockDeleteOrderInspect() {
	for _, e := range m.DeleteOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.DeleteOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteOrderCounter := mm_atomic.LoadUint64(&m.afterDeleteOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteOrderMock.defaultExpectation != nil && afterDeleteOrderCounter < 1 {
		if m.DeleteOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.DeleteOrder at\n%s", m.DeleteOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.DeleteOrder at\n%s with params: %#v", m.DeleteOrderMock.defaultExpectation.expectationOrigins.origin, *m.DeleteOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteOrder != nil && afterDeleteOrderCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.DeleteOrder at\n%s", m.funcDeleteOrderOrigin)
	}

	if !m.DeleteOrderMock.invocationsDone() && afterDeleteOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.DeleteOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteOrderMock.expectedInvocations), m.DeleteOrderMock.expectedInvocationsOrigin, afterDeleteOrderCounter)
	}
}

type mStorageMockGetHistory struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGetHistoryExpectation
	expectations       []*StorageMockGetHistoryExpectation

	callArgs []*StorageMockGetHistoryParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGetHistoryExpectation specifies expectation struct of the Storage.GetHistory
type StorageMockGetHistoryExpectation struct {
	mock               *StorageMock
	params             *StorageMockGetHistoryParams
	paramPtrs          *StorageMockGetHistoryParamPtrs
	expectationOrigins StorageMockGetHistoryExpectationOrigins
	results            *StorageMockGetHistoryResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockGetHistoryParams contains parameters of the Storage.GetHistory
type StorageMockGetHistoryParams struct {
	ctx   context.Context
	page  uint32
	count uint32
}

// StorageMockGetHistoryParamPtrs contains pointers to parameters of the Storage.GetHistory
type StorageMockGetHistoryParamPtrs struct {
	ctx   *context.Context
	page  *uint32
	count *uint32
}

// StorageMockGetHistoryResults contains results of the Storage.GetHistory
type StorageMockGetHistoryResults struct {
	oa1 []models.OrderHistory
	err error
}

// StorageMockGetHistoryOrigins contains origins of expectations of the Storage.GetHistory
type StorageMockGetHistoryExpectationOrigins struct {
	origin      string
	originCtx   string
	originPage  string
	originCount string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetHistory *mStorageMockGetHistory) Optional() *mStorageMockGetHistory {
	mmGetHistory.optional = true
	return mmGetHistory
}

// Expect sets up expected params for Storage.GetHistory
func (mmGetHistory *mStorageMockGetHistory) Expect(ctx context.Context, page uint32, count uint32) *mStorageMockGetHistory {
	if mmGetHistory.mock.funcGetHistory != nil {
		mmGetHistory.mock.t.Fatalf("StorageMock.GetHistory mock is already set by Set")
	}

	if mmGetHistory.defaultExpectation == nil {
		mmGetHistory.defaultExpectation = &StorageMockGetHistoryExpectation{}
	}

	if mmGetHistory.defaultExpectation.paramPtrs != nil {
		mmGetHistory.mock.t.Fatalf("StorageMock.GetHistory mock is already set by ExpectParams functions")
	}

	mmGetHistory.defaultExpectation.params = &StorageMockGetHistoryParams{ctx, page, count}
	mmGetHistory.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetHistory.expectations {
		if minimock.Equal(e.params, mmGetHistory.defaultExpectation.params) {
			mmGetHistory.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetHistory.defaultExpectation.params)
		}
	}

	return mmGetHistory
}

// ExpectCtxParam1 sets up expected param ctx for Storage.GetHistory
func (mmGetHistory *mStorageMockGetHistory) ExpectCtxParam1(ctx context.Context) *mStorageMockGetHistory {
	if mmGetHistory.mock.funcGetHistory != nil {
		mmGetHistory.mock.t.Fatalf("StorageMock.GetHistory mock is already set by Set")
	}

	if mmGetHistory.defaultExpectation == nil {
		mmGetHistory.defaultExpectation = &StorageMockGetHistoryExpectation{}
	}

	if mmGetHistory.defaultExpectation.params != nil {
		mmGetHistory.mock.t.Fatalf("StorageMock.GetHistory mock is already set by Expect")
	}

	if mmGetHistory.defaultExpectation.paramPtrs == nil {
		mmGetHistory.defaultExpectation.paramPtrs = &StorageMockGetHistoryParamPtrs{}
	}
	mmGetHistory.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetHistory.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetHistory
}

// ExpectPageParam2 sets up expected param page for Storage.GetHistory
func (mmGetHistory *mStorageMockGetHistory) ExpectPageParam2(page uint32) *mStorageMockGetHistory {
	if mmGetHistory.mock.funcGetHistory != nil {
		mmGetHistory.mock.t.Fatalf("StorageMock.GetHistory mock is already set by Set")
	}

	if mmGetHistory.defaultExpectation == nil {
		mmGetHistory.defaultExpectation = &StorageMockGetHistoryExpectation{}
	}

	if mmGetHistory.defaultExpectation.params != nil {
		mmGetHistory.mock.t.Fatalf("StorageMock.GetHistory mock is already set by Expect")
	}

	if mmGetHistory.defaultExpectation.paramPtrs == nil {
		mmGetHistory.defaultExpectation.paramPtrs = &StorageMockGetHistoryParamPtrs{}
	}
	mmGetHistory.defaultExpectation.paramPtrs.page = &page
	mmGetHistory.defaultExpectation.expectationOrigins.originPage = minimock.CallerInfo(1)

	return mmGetHistory
}

// ExpectCountParam3 sets up expected param count for Storage.GetHistory
func (mmGetHistory *mStorageMockGetHistory) ExpectCountParam3(count uint32) *mStorageMockGetHistory {
	if mmGetHistory.mock.funcGetHistory != nil {
		mmGetHistory.mock.t.Fatalf("StorageMock.GetHistory mock is already set by Set")
	}

	if mmGetHistory.defaultExpectation == nil {
		mmGetHistory.defaultExpectation = &StorageMockGetHistoryExpectation{}
	}

	if mmGetHistory.defaultExpectation.params != nil {
		mmGetHistory.mock.t.Fatalf("StorageMock.GetHistory mock is already set by Expect")
	}

	if mmGetHistory.defaultExpectation.paramPtrs == nil {
		mmGetHistory.defaultExpectation.paramPtrs = &StorageMockGetHistoryParamPtrs{}
	}
	mmGetHistory.defaultExpectation.paramPtrs.count = &count
	mmGetHistory.defaultExpectation.expectationOrigins.originCount = minimock.CallerInfo(1)

	return mmGetHistory
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetHistory
func (mmGetHistory *mStorageMockGetHistory) Inspect(f func(ctx context.Context, page uint32, count uint32)) *mStorageMockGetHistory {
	if mmGetHistory.mock.inspectFuncGetHistory != nil {
		mmGetHistory.mock.t.Fatalf("Inspect function is already set for StorageMock.GetHistory")
	}

	mmGetHistory.mock.inspectFuncGetHistory = f

	return mmGetHistory
}

// Return sets up results that will be returned by Storage.GetHistory
func (mmGetHistory *mStorageMockGetHistory) Return(oa1 []models.OrderHistory, err error) *StorageMock {
	if mmGetHistory.mock.funcGetHistory != nil {
		mmGetHistory.mock.t.Fatalf("StorageMock.GetHistory mock is already set by Set")
	}

	if mmGetHistory.defaultExpectation == nil {
		mmGetHistory.defaultExpectation = &StorageMockGetHistoryExpectation{mock: mmGetHistory.mock}
	}
	mmGetHistory.defaultExpectation.results = &StorageMockGetHistoryResults{oa1, err}
	mmGetHistory.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetHistory.mock
}

// Set uses given function f to mock the Storage.GetHistory method
func (mmGetHistory *mStorageMockGetHistory) Set(f func(ctx context.Context, page uint32, count uint32) (oa1 []models.OrderHistory, err error)) *StorageMock {
	if mmGetHistory.defaultExpectation != nil {
		mmGetHistory.mock.t.Fatalf("Default expectation is already set for the Storage.GetHistory method")
	}

	if len(mmGetHistory.expectations) > 0 {
		mmGetHistory.mock.t.Fatalf("Some expectations are already set for the Storage.GetHistory method")
	}

	mmGetHistory.mock.funcGetHistory = f
	mmGetHistory.mock.funcGetHistoryOrigin = minimock.CallerInfo(1)
	return mmGetHistory.mock
}

// When sets expectation for the Storage.GetHistory which will trigger the result defined by the following
// Then helper
func (mmGetHistory *mStorageMockGetHistory) When(ctx context.Context, page uint32, count uint32) *StorageMockGetHistoryExpectation {
	if mmGetHistory.mock.funcGetHistory != nil {
		mmGetHistory.mock.t.Fatalf("StorageMock.GetHistory mock is already set by Set")
	}

	expectation := &StorageMockGetHistoryExpectation{
		mock:               mmGetHistory.mock,
		params:             &StorageMockGetHistoryParams{ctx, page, count},
		expectationOrigins: StorageMockGetHistoryExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetHistory.expectations = append(mmGetHistory.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetHistory return parameters for the expectation previously defined by the When method
func (e *StorageMockGetHistoryExpectation) Then(oa1 []models.OrderHistory, err error) *StorageMock {
	e.results = &StorageMockGetHistoryResults{oa1, err}
	return e.mock
}

// Times sets number of times Storage.GetHistory should be invoked
func (mmGetHistory *mStorageMockGetHistory) Times(n uint64) *mStorageMockGetHistory {
	if n == 0 {
		mmGetHistory.mock.t.Fatalf("Times of StorageMock.GetHistory mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetHistory.expectedInvocations, n)
	mmGetHistory.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetHistory
}

func (mmGetHistory *mStorageMockGetHistory) invocationsDone() bool {
	if len(mmGetHistory.expectations) == 0 && mmGetHistory.defaultExpectation == nil && mmGetHistory.mock.funcGetHistory == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetHistory.mock.afterGetHistoryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetHistory.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetHistory implements mm_storage.Storage
func (mmGetHistory *StorageMock) GetHistory(ctx context.Context, page uint32, count uint32) (oa1 []models.OrderHistory, err error) {
	mm_atomic.AddUint64(&mmGetHistory.beforeGetHistoryCounter, 1)
	defer mm_atomic.AddUint64(&mmGetHistory.afterGetHistoryCounter, 1)

	mmGetHistory.t.Helper()

	if mmGetHistory.inspectFuncGetHistory != nil {
		mmGetHistory.inspectFuncGetHistory(ctx, page, count)
	}

	mm_params := StorageMockGetHistoryParams{ctx, page, count}

	// Record call args
	mmGetHistory.GetHistoryMock.mutex.Lock()
	mmGetHistory.GetHistoryMock.callArgs = append(mmGetHistory.GetHistoryMock.callArgs, &mm_params)
	mmGetHistory.GetHistoryMock.mutex.Unlock()

	for _, e := range mmGetHistory.GetHistoryMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmGetHistory.GetHistoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetHistory.GetHistoryMock.defaultExpectation.Counter, 1)
		mm_want := mmGetHistory.GetHistoryMock.defaultExpectation.params
		mm_want_ptrs := mmGetHistory.GetHistoryMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGetHistoryParams{ctx, page, count}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetHistory.t.Errorf("StorageMock.GetHistory got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetHistory.GetHistoryMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.page != nil && !minimock.Equal(*mm_want_ptrs.page, mm_got.page) {
				mmGetHistory.t.Errorf("StorageMock.GetHistory got unexpected parameter page, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetHistory.GetHistoryMock.defaultExpectation.expectationOrigins.originPage, *mm_want_ptrs.page, mm_got.page, minimock.Diff(*mm_want_ptrs.page, mm_got.page))
			}

			if mm_want_ptrs.count != nil && !minimock.Equal(*mm_want_ptrs.count, mm_got.count) {
				mmGetHistory.t.Errorf("StorageMock.GetHistory got unexpected parameter count, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetHistory.GetHistoryMock.defaultExpectation.expectationOrigins.originCount, *mm_want_ptrs.count, mm_got.count, minimock.Diff(*mm_want_ptrs.count, mm_got.count))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetHistory.t.Errorf("StorageMock.GetHistory got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetHistory.GetHistoryMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetHistory.GetHistoryMock.defaultExpectation.results
		if mm_results == nil {
			mmGetHistory.t.Fatal("No results are set for the StorageMock.GetHistory")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmGetHistory.funcGetHistory != nil {
		return mmGetHistory.funcGetHistory(ctx, page, count)
	}
	mmGetHistory.t.Fatalf("Unexpected call to StorageMock.GetHistory. %v %v %v", ctx, page, count)
	return
}

// GetHistoryAfterCounter returns a count of finished StorageMock.GetHistory invocations
func (mmGetHistory *StorageMock) GetHistoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetHistory.afterGetHistoryCounter)
}

// GetHistoryBeforeCounter returns a count of StorageMock.GetHistory invocations
func (mmGetHistory *StorageMock) GetHistoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetHistory.beforeGetHistoryCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetHistory.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetHistory *mStorageMockGetHistory) Calls() []*StorageMockGetHistoryParams {
	mmGetHistory.mutex.RLock()

	argCopy := make([]*StorageMockGetHistoryParams, len(mmGetHistory.callArgs))
	copy(argCopy, mmGetHistory.callArgs)

	mmGetHistory.mutex.RUnlock()

	return argCopy
}

// MinimockGetHistoryDone returns true if the count of the GetHistory invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetHistoryDone() bool {
	if m.GetHistoryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetHistoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetHistoryMock.invocationsDone()
}

// MinimockGetHistoryInspect logs each unmet expectation
func (m *StorageMock) MinimockGetHistoryInspect() {
	for _, e := range m.GetHistoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetHistory at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetHistoryCounter := mm_atomic.LoadUint64(&m.afterGetHistoryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetHistoryMock.defaultExpectation != nil && afterGetHistoryCounter < 1 {
		if m.GetHistoryMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.GetHistory at\n%s", m.GetHistoryMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.GetHistory at\n%s with params: %#v", m.GetHistoryMock.defaultExpectation.expectationOrigins.origin, *m.GetHistoryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetHistory != nil && afterGetHistoryCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GetHistory at\n%s", m.funcGetHistoryOrigin)
	}

	if !m.GetHistoryMock.invocationsDone() && afterGetHistoryCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GetHistory at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetHistoryMock.expectedInvocations), m.GetHistoryMock.expectedInvocationsOrigin, afterGetHistoryCounter)
	}
}

type mStorageMockGetOrder struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGetOrderExpectation
	expectations       []*StorageMockGetOrderExpectation

	callArgs []*StorageMockGetOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGetOrderExpectation specifies expectation struct of the Storage.GetOrder
type StorageMockGetOrderExpectation struct {
	mock               *StorageMock
	params             *StorageMockGetOrderParams
	paramPtrs          *StorageMockGetOrderParamPtrs
	expectationOrigins StorageMockGetOrderExpectationOrigins
	results            *StorageMockGetOrderResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockGetOrderParams contains parameters of the Storage.GetOrder
type StorageMockGetOrderParams struct {
	ctx context.Context
	id  uint64
}

// StorageMockGetOrderParamPtrs contains pointers to parameters of the Storage.GetOrder
type StorageMockGetOrderParamPtrs struct {
	ctx *context.Context
	id  *uint64
}

// StorageMockGetOrderResults contains results of the Storage.GetOrder
type StorageMockGetOrderResults struct {
	o1  models.Order
	err error
}

// StorageMockGetOrderOrigins contains origins of expectations of the Storage.GetOrder
type StorageMockGetOrderExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrder *mStorageMockGetOrder) Optional() *mStorageMockGetOrder {
	mmGetOrder.optional = true
	return mmGetOrder
}

// Expect sets up expected params for Storage.GetOrder
func (mmGetOrder *mStorageMockGetOrder) Expect(ctx context.Context, id uint64) *mStorageMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("StorageMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &StorageMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.paramPtrs != nil {
		mmGetOrder.mock.t.Fatalf("StorageMock.GetOrder mock is already set by ExpectParams functions")
	}

	mmGetOrder.defaultExpectation.params = &StorageMockGetOrderParams{ctx, id}
	mmGetOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrder.expectations {
		if minimock.Equal(e.params, mmGetOrder.defaultExpectation.params) {
			mmGetOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrder.defaultExpectation.params)
		}
	}

	return mmGetOrder
}

// ExpectCtxParam1 sets up expected param ctx for Storage.GetOrder
func (mmGetOrder *mStorageMockGetOrder) ExpectCtxParam1(ctx context.Context) *mStorageMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("StorageMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &StorageMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.params != nil {
		mmGetOrder.mock.t.Fatalf("StorageMock.GetOrder mock is already set by Expect")
	}

	if mmGetOrder.defaultExpectation.paramPtrs == nil {
		mmGetOrder.defaultExpectation.paramPtrs = &StorageMockGetOrderParamPtrs{}
	}
	mmGetOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetOrder
}

// ExpectIdParam2 sets up expected param id for Storage.GetOrder
func (mmGetOrder *mStorageMockGetOrder) ExpectIdParam2(id uint64) *mStorageMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("StorageMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &StorageMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.params != nil {
		mmGetOrder.mock.t.Fatalf("StorageMock.GetOrder mock is already set by Expect")
	}

	if mmGetOrder.defaultExpectation.paramPtrs == nil {
		mmGetOrder.defaultExpectation.paramPtrs = &StorageMockGetOrderParamPtrs{}
	}
	mmGetOrder.defaultExpectation.paramPtrs.id = &id
	mmGetOrder.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetOrder
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetOrder
func (mmGetOrder *mStorageMockGetOrder) Inspect(f func(ctx context.Context, id uint64)) *mStorageMockGetOrder {
	if mmGetOrder.mock.inspectFuncGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("Inspect function is already set for StorageMock.GetOrder")
	}

	mmGetOrder.mock.inspectFuncGetOrder = f

	return mmGetOrder
}

// Return sets up results that will be returned by Storage.GetOrder
func (mmGetOrder *mStorageMockGetOrder) Return(o1 models.Order, err error) *StorageMock {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("StorageMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &StorageMockGetOrderExpectation{mock: mmGetOrder.mock}
	}
	mmGetOrder.defaultExpectation.results = &StorageMockGetOrderResults{o1, err}
	mmGetOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrder.mock
}

// Set uses given function f to mock the Storage.GetOrder method
func (mmGetOrder *mStorageMockGetOrder) Set(f func(ctx context.Context, id uint64) (o1 models.Order, err error)) *StorageMock {
	if mmGetOrder.defaultExpectation != nil {
		mmGetOrder.mock.t.Fatalf("Default expectation is already set for the Storage.GetOrder method")
	}

	if len(mmGetOrder.expectations) > 0 {
		mmGetOrder.mock.t.Fatalf("Some expectations are already set for the Storage.GetOrder method")
	}

	mmGetOrder.mock.funcGetOrder = f
	mmGetOrder.mock.funcGetOrderOrigin = minimock.CallerInfo(1)
	return mmGetOrder.mock
}

// When sets expectation for the Storage.GetOrder which will trigger the result defined by the following
// Then helper
func (mmGetOrder *mStorageMockGetOrder) When(ctx context.Context, id uint64) *StorageMockGetOrderExpectation {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("StorageMock.GetOrder mock is already set by Set")
	}

	expectation := &StorageMockGetOrderExpectation{
		mock:               mmGetOrder.mock,
		params:             &StorageMockGetOrderParams{ctx, id},
		expectationOrigins: StorageMockGetOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrder.expectations = append(mmGetOrder.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetOrder return parameters for the expectation previously defined by the When method
func (e *StorageMockGetOrderExpectation) Then(o1 models.Order, err error) *StorageMock {
	e.results = &StorageMockGetOrderResults{o1, err}
	return e.mock
}

// Times sets number of times Storage.GetOrder should be invoked
func (mmGetOrder *mStorageMockGetOrder) Times(n uint64) *mStorageMockGetOrder {
	if n == 0 {
		mmGetOrder.mock.t.Fatalf("Times of StorageMock.GetOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrder.expectedInvocations, n)
	mmGetOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrder
}

func (mmGetOrder *mStorageMockGetOrder) invocationsDone() bool {
	if len(mmGetOrder.expectations) == 0 && mmGetOrder.defaultExpectation == nil && mmGetOrder.mock.funcGetOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrder.mock.afterGetOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrder implements mm_storage.Storage
func (mmGetOrder *StorageMock) GetOrder(ctx context.Context, id uint64) (o1 models.Order, err error) {
	mm_atomic.AddUint64(&mmGetOrder.beforeGetOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrder.afterGetOrderCounter, 1)

	mmGetOrder.t.Helper()

	if mmGetOrder.inspectFuncGetOrder != nil {
		mmGetOrder.inspectFuncGetOrder(ctx, id)
	}

	mm_params := StorageMockGetOrderParams{ctx, id}

	// Record call args
	mmGetOrder.GetOrderMock.mutex.Lock()
	mmGetOrder.GetOrderMock.callArgs = append(mmGetOrder.GetOrderMock.callArgs, &mm_params)
	mmGetOrder.GetOrderMock.mutex.Unlock()

	for _, e := range mmGetOrder.GetOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmGetOrder.GetOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrder.GetOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrder.GetOrderMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrder.GetOrderMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGetOrderParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrder.t.Errorf("StorageMock.GetOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrder.GetOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetOrder.t.Errorf("StorageMock.GetOrder got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrder.GetOrderMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrder.t.Errorf("StorageMock.GetOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrder.GetOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrder.GetOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrder.t.Fatal("No results are set for the StorageMock.GetOrder")
		}
		return (*mm_results).o1, (*mm_results).err
	}
	if mmGetOrder.funcGetOrder != nil {
		return mmGetOrder.funcGetOrder(ctx, id)
	}
	mmGetOrder.t.Fatalf("Unexpected call to StorageMock.GetOrder. %v %v", ctx, id)
	return
}

// GetOrderAfterCounter returns a count of finished StorageMock.GetOrder invocations
func (mmGetOrder *StorageMock) GetOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrder.afterGetOrderCounter)
}

// GetOrderBeforeCounter returns a count of StorageMock.GetOrder invocations
func (mmGetOrder *StorageMock) GetOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrder.beforeGetOrderCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrder *mStorageMockGetOrder) Calls() []*StorageMockGetOrderParams {
	mmGetOrder.mutex.RLock()

	argCopy := make([]*StorageMockGetOrderParams, len(mmGetOrder.callArgs))
	copy(argCopy, mmGetOrder.callArgs)

	mmGetOrder.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrderDone returns true if the count of the GetOrder invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetOrderDone() bool {
	if m.GetOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrderMock.invocationsDone()
}

// MinimockGetOrderInspect logs each unmet expectation
func (m *StorageMock) MinimockGetOrderInspect() {
	for _, e := range m.GetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrderCounter := mm_atomic.LoadUint64(&m.afterGetOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderMock.defaultExpectation != nil && afterGetOrderCounter < 1 {
		if m.GetOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.GetOrder at\n%s", m.GetOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.GetOrder at\n%s with params: %#v", m.GetOrderMock.defaultExpectation.expectationOrigins.origin, *m.GetOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrder != nil && afterGetOrderCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GetOrder at\n%s", m.funcGetOrderOrigin)
	}

	if !m.GetOrderMock.invocationsDone() && afterGetOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GetOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrderMock.expectedInvocations), m.GetOrderMock.expectedInvocationsOrigin, afterGetOrderCounter)
	}
}

type mStorageMockListOrders struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockListOrdersExpectation
	expectations       []*StorageMockListOrdersExpectation

	callArgs []*StorageMockListOrdersParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockListOrdersExpectation specifies expectation struct of the Storage.ListOrders
type StorageMockListOrdersExpectation struct {
	mock               *StorageMock
	params             *StorageMockListOrdersParams
	paramPtrs          *StorageMockListOrdersParamPtrs
	expectationOrigins StorageMockListOrdersExpectationOrigins
	results            *StorageMockListOrdersResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockListOrdersParams contains parameters of the Storage.ListOrders
type StorageMockListOrdersParams struct {
	ctx context.Context
}

// StorageMockListOrdersParamPtrs contains pointers to parameters of the Storage.ListOrders
type StorageMockListOrdersParamPtrs struct {
	ctx *context.Context
}

// StorageMockListOrdersResults contains results of the Storage.ListOrders
type StorageMockListOrdersResults struct {
	oa1 []models.Order
	err error
}

// StorageMockListOrdersOrigins contains origins of expectations of the Storage.ListOrders
type StorageMockListOrdersExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListOrders *mStorageMockListOrders) Optional() *mStorageMockListOrders {
	mmListOrders.optional = true
	return mmListOrders
}

// Expect sets up expected params for Storage.ListOrders
func (mmListOrders *mStorageMockListOrders) Expect(ctx context.Context) *mStorageMockListOrders {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("StorageMock.ListOrders mock is already set by Set")
	}

	if mmListOrders.defaultExpectation == nil {
		mmListOrders.defaultExpectation = &StorageMockListOrdersExpectation{}
	}

	if mmListOrders.defaultExpectation.paramPtrs != nil {
		mmListOrders.mock.t.Fatalf("StorageMock.ListOrders mock is already set by ExpectParams functions")
	}

	mmListOrders.defaultExpectation.params = &StorageMockListOrdersParams{ctx}
	mmListOrders.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListOrders.expectations {
		if minimock.Equal(e.params, mmListOrders.defaultExpectation.params) {
			mmListOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListOrders.defaultExpectation.params)
		}
	}

	return mmListOrders
}

// ExpectCtxParam1 sets up expected param ctx for Storage.ListOrders
func (mmListOrders *mStorageMockListOrders) ExpectCtxParam1(ctx context.Context) *mStorageMockListOrders {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("StorageMock.ListOrders mock is already set by Set")
	}

	if mmListOrders.defaultExpectation == nil {
		mmListOrders.defaultExpectation = &StorageMockListOrdersExpectation{}
	}

	if mmListOrders.defaultExpectation.params != nil {
		mmListOrders.mock.t.Fatalf("StorageMock.ListOrders mock is already set by Expect")
	}

	if mmListOrders.defaultExpectation.paramPtrs == nil {
		mmListOrders.defaultExpectation.paramPtrs = &StorageMockListOrdersParamPtrs{}
	}
	mmListOrders.defaultExpectation.paramPtrs.ctx = &ctx
	mmListOrders.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListOrders
}

// Inspect accepts an inspector function that has same arguments as the Storage.ListOrders
func (mmListOrders *mStorageMockListOrders) Inspect(f func(ctx context.Context)) *mStorageMockListOrders {
	if mmListOrders.mock.inspectFuncListOrders != nil {
		mmListOrders.mock.t.Fatalf("Inspect function is already set for StorageMock.ListOrders")
	}

	mmListOrders.mock.inspectFuncListOrders = f

	return mmListOrders
}

// Return sets up results that will be returned by Storage.ListOrders
func (mmListOrders *mStorageMockListOrders) Return(oa1 []models.Order, err error) *StorageMock {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("StorageMock.ListOrders mock is already set by Set")
	}

	if mmListOrders.defaultExpectation == nil {
		mmListOrders.defaultExpectation = &StorageMockListOrdersExpectation{mock: mmListOrders.mock}
	}
	mmListOrders.defaultExpectation.results = &StorageMockListOrdersResults{oa1, err}
	mmListOrders.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListOrders.mock
}

// Set uses given function f to mock the Storage.ListOrders method
func (mmListOrders *mStorageMockListOrders) Set(f func(ctx context.Context) (oa1 []models.Order, err error)) *StorageMock {
	if mmListOrders.defaultExpectation != nil {
		mmListOrders.mock.t.Fatalf("Default expectation is already set for the Storage.ListOrders method")
	}

	if len(mmListOrders.expectations) > 0 {
		mmListOrders.mock.t.Fatalf("Some expectations are already set for the Storage.ListOrders method")
	}

	mmListOrders.mock.funcListOrders = f
	mmListOrders.mock.funcListOrdersOrigin = minimock.CallerInfo(1)
	return mmListOrders.mock
}

// When sets expectation for the Storage.ListOrders which will trigger the result defined by the following
// Then helper
func (mmListOrders *mStorageMockListOrders) When(ctx context.Context) *StorageMockListOrdersExpectation {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("StorageMock.ListOrders mock is already set by Set")
	}

	expectation := &StorageMockListOrdersExpectation{
		mock:               mmListOrders.mock,
		params:             &StorageMockListOrdersParams{ctx},
		expectationOrigins: StorageMockListOrdersExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListOrders.expectations = append(mmListOrders.expectations, expectation)
	return expectation
}

// Then sets up Storage.ListOrders return parameters for the expectation previously defined by the When method
func (e *StorageMockListOrdersExpectation) Then(oa1 []models.Order, err error) *StorageMock {
	e.results = &StorageMockListOrdersResults{oa1, err}
	return e.mock
}

// Times sets number of times Storage.ListOrders should be invoked
func (mmListOrders *mStorageMockListOrders) Times(n uint64) *mStorageMockListOrders {
	if n == 0 {
		mmListOrders.mock.t.Fatalf("Times of StorageMock.ListOrders mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListOrders.expectedInvocations, n)
	mmListOrders.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListOrders
}

func (mmListOrders *mStorageMockListOrders) invocationsDone() bool {
	if len(mmListOrders.expectations) == 0 && mmListOrders.defaultExpectation == nil && mmListOrders.mock.funcListOrders == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListOrders.mock.afterListOrdersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListOrders.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListOrders implements mm_storage.Storage
func (mmListOrders *StorageMock) ListOrders(ctx context.Context) (oa1 []models.Order, err error) {
	mm_atomic.AddUint64(&mmListOrders.beforeListOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmListOrders.afterListOrdersCounter, 1)

	mmListOrders.t.Helper()

	if mmListOrders.inspectFuncListOrders != nil {
		mmListOrders.inspectFuncListOrders(ctx)
	}

	mm_params := StorageMockListOrdersParams{ctx}

	// Record call args
	mmListOrders.ListOrdersMock.mutex.Lock()
	mmListOrders.ListOrdersMock.callArgs = append(mmListOrders.ListOrdersMock.callArgs, &mm_params)
	mmListOrders.ListOrdersMock.mutex.Unlock()

	for _, e := range mmListOrders.ListOrdersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmListOrders.ListOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListOrders.ListOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmListOrders.ListOrdersMock.defaultExpectation.params
		mm_want_ptrs := mmListOrders.ListOrdersMock.defaultExpectation.paramPtrs

		mm_got := StorageMockListOrdersParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListOrders.t.Errorf("StorageMock.ListOrders got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListOrders.ListOrdersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListOrders.t.Errorf("StorageMock.ListOrders got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListOrders.ListOrdersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListOrders.ListOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmListOrders.t.Fatal("No results are set for the StorageMock.ListOrders")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmListOrders.funcListOrders != nil {
		return mmListOrders.funcListOrders(ctx)
	}
	mmListOrders.t.Fatalf("Unexpected call to StorageMock.ListOrders. %v", ctx)
	return
}

// ListOrdersAfterCounter returns a count of finished StorageMock.ListOrders invocations
func (mmListOrders *StorageMock) ListOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOrders.afterListOrdersCounter)
}

// ListOrdersBeforeCounter returns a count of StorageMock.ListOrders invocations
func (mmListOrders *StorageMock) ListOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOrders.beforeListOrdersCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.ListOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListOrders *mStorageMockListOrders) Calls() []*StorageMockListOrdersParams {
	mmListOrders.mutex.RLock()

	argCopy := make([]*StorageMockListOrdersParams, len(mmListOrders.callArgs))
	copy(argCopy, mmListOrders.callArgs)

	mmListOrders.mutex.RUnlock()

	return argCopy
}

// MinimockListOrdersDone returns true if the count of the ListOrders invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockListOrdersDone() bool {
	if m.ListOrdersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListOrdersMock.invocationsDone()
}

// MinimockListOrdersInspect logs each unmet expectation
func (m *StorageMock) MinimockListOrdersInspect() {
	for _, e := range m.ListOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.ListOrders at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListOrdersCounter := mm_atomic.LoadUint64(&m.afterListOrdersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListOrdersMock.defaultExpectation != nil && afterListOrdersCounter < 1 {
		if m.ListOrdersMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.ListOrders at\n%s", m.ListOrdersMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.ListOrders at\n%s with params: %#v", m.ListOrdersMock.defaultExpectation.expectationOrigins.origin, *m.ListOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListOrders != nil && afterListOrdersCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.ListOrders at\n%s", m.funcListOrdersOrigin)
	}

	if !m.ListOrdersMock.invocationsDone() && afterListOrdersCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.ListOrders at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListOrdersMock.expectedInvocations), m.ListOrdersMock.expectedInvocationsOrigin, afterListOrdersCounter)
	}
}

type mStorageMockSaveOrderTx struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockSaveOrderTxExpectation
	expectations       []*StorageMockSaveOrderTxExpectation

	callArgs []*StorageMockSaveOrderTxParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockSaveOrderTxExpectation specifies expectation struct of the Storage.SaveOrderTx
type StorageMockSaveOrderTxExpectation struct {
	mock               *StorageMock
	params             *StorageMockSaveOrderTxParams
	paramPtrs          *StorageMockSaveOrderTxParamPtrs
	expectationOrigins StorageMockSaveOrderTxExpectationOrigins
	results            *StorageMockSaveOrderTxResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockSaveOrderTxParams contains parameters of the Storage.SaveOrderTx
type StorageMockSaveOrderTxParams struct {
	ctx   context.Context
	tx    pgx.Tx
	order models.Order
}

// StorageMockSaveOrderTxParamPtrs contains pointers to parameters of the Storage.SaveOrderTx
type StorageMockSaveOrderTxParamPtrs struct {
	ctx   *context.Context
	tx    *pgx.Tx
	order *models.Order
}

// StorageMockSaveOrderTxResults contains results of the Storage.SaveOrderTx
type StorageMockSaveOrderTxResults struct {
	err error
}

// StorageMockSaveOrderTxOrigins contains origins of expectations of the Storage.SaveOrderTx
type StorageMockSaveOrderTxExpectationOrigins struct {
	origin      string
	originCtx   string
	originTx    string
	originOrder string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSaveOrderTx *mStorageMockSaveOrderTx) Optional() *mStorageMockSaveOrderTx {
	mmSaveOrderTx.optional = true
	return mmSaveOrderTx
}

// Expect sets up expected params for Storage.SaveOrderTx
func (mmSaveOrderTx *mStorageMockSaveOrderTx) Expect(ctx context.Context, tx pgx.Tx, order models.Order) *mStorageMockSaveOrderTx {
	if mmSaveOrderTx.mock.funcSaveOrderTx != nil {
		mmSaveOrderTx.mock.t.Fatalf("StorageMock.SaveOrderTx mock is already set by Set")
	}

	if mmSaveOrderTx.defaultExpectation == nil {
		mmSaveOrderTx.defaultExpectation = &StorageMockSaveOrderTxExpectation{}
	}

	if mmSaveOrderTx.defaultExpectation.paramPtrs != nil {
		mmSaveOrderTx.mock.t.Fatalf("StorageMock.SaveOrderTx mock is already set by ExpectParams functions")
	}

	mmSaveOrderTx.defaultExpectation.params = &StorageMockSaveOrderTxParams{ctx, tx, order}
	mmSaveOrderTx.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSaveOrderTx.expectations {
		if minimock.Equal(e.params, mmSaveOrderTx.defaultExpectation.params) {
			mmSaveOrderTx.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveOrderTx.defaultExpectation.params)
		}
	}

	return mmSaveOrderTx
}

// ExpectCtxParam1 sets up expected param ctx for Storage.SaveOrderTx
func (mmSaveOrderTx *mStorageMockSaveOrderTx) ExpectCtxParam1(ctx context.Context) *mStorageMockSaveOrderTx {
	if mmSaveOrderTx.mock.funcSaveOrderTx != nil {
		mmSaveOrderTx.mock.t.Fatalf("StorageMock.SaveOrderTx mock is already set by Set")
	}

	if mmSaveOrderTx.defaultExpectation == nil {
		mmSaveOrderTx.defaultExpectation = &StorageMockSaveOrderTxExpectation{}
	}

	if mmSaveOrderTx.defaultExpectation.params != nil {
		mmSaveOrderTx.mock.t.Fatalf("StorageMock.SaveOrderTx mock is already set by Expect")
	}

	if mmSaveOrderTx.defaultExpectation.paramPtrs == nil {
		mmSaveOrderTx.defaultExpectation.paramPtrs = &StorageMockSaveOrderTxParamPtrs{}
	}
	mmSaveOrderTx.defaultExpectation.paramPtrs.ctx = &ctx
	mmSaveOrderTx.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSaveOrderTx
}

// ExpectTxParam2 sets up expected param tx for Storage.SaveOrderTx
func (mmSaveOrderTx *mStorageMockSaveOrderTx) ExpectTxParam2(tx pgx.Tx) *mStorageMockSaveOrderTx {
	if mmSaveOrderTx.mock.funcSaveOrderTx != nil {
		mmSaveOrderTx.mock.t.Fatalf("StorageMock.SaveOrderTx mock is already set by Set")
	}

	if mmSaveOrderTx.defaultExpectation == nil {
		mmSaveOrderTx.defaultExpectation = &StorageMockSaveOrderTxExpectation{}
	}

	if mmSaveOrderTx.defaultExpectation.params != nil {
		mmSaveOrderTx.mock.t.Fatalf("StorageMock.SaveOrderTx mock is already set by Expect")
	}

	if mmSaveOrderTx.defaultExpectation.paramPtrs == nil {
		mmSaveOrderTx.defaultExpectation.paramPtrs = &StorageMockSaveOrderTxParamPtrs{}
	}
	mmSaveOrderTx.defaultExpectation.paramPtrs.tx = &tx
	mmSaveOrderTx.defaultExpectation.expectationOrigins.originTx = minimock.CallerInfo(1)

	return mmSaveOrderTx
}

// ExpectOrderParam3 sets up expected param order for Storage.SaveOrderTx
func (mmSaveOrderTx *mStorageMockSaveOrderTx) ExpectOrderParam3(order models.Order) *mStorageMockSaveOrderTx {
	if mmSaveOrderTx.mock.funcSaveOrderTx != nil {
		mmSaveOrderTx.mock.t.Fatalf("StorageMock.SaveOrderTx mock is already set by Set")
	}

	if mmSaveOrderTx.defaultExpectation == nil {
		mmSaveOrderTx.defaultExpectation = &StorageMockSaveOrderTxExpectation{}
	}

	if mmSaveOrderTx.defaultExpectation.params != nil {
		mmSaveOrderTx.mock.t.Fatalf("StorageMock.SaveOrderTx mock is already set by Expect")
	}

	if mmSaveOrderTx.defaultExpectation.paramPtrs == nil {
		mmSaveOrderTx.defaultExpectation.paramPtrs = &StorageMockSaveOrderTxParamPtrs{}
	}
	mmSaveOrderTx.defaultExpectation.paramPtrs.order = &order
	mmSaveOrderTx.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmSaveOrderTx
}

// Inspect accepts an inspector function that has same arguments as the Storage.SaveOrderTx
func (mmSaveOrderTx *mStorageMockSaveOrderTx) Inspect(f func(ctx context.Context, tx pgx.Tx, order models.Order)) *mStorageMockSaveOrderTx {
	if mmSaveOrderTx.mock.inspectFuncSaveOrderTx != nil {
		mmSaveOrderTx.mock.t.Fatalf("Inspect function is already set for StorageMock.SaveOrderTx")
	}

	mmSaveOrderTx.mock.inspectFuncSaveOrderTx = f

	return mmSaveOrderTx
}

// Return sets up results that will be returned by Storage.SaveOrderTx
func (mmSaveOrderTx *mStorageMockSaveOrderTx) Return(err error) *StorageMock {
	if mmSaveOrderTx.mock.funcSaveOrderTx != nil {
		mmSaveOrderTx.mock.t.Fatalf("StorageMock.SaveOrderTx mock is already set by Set")
	}

	if mmSaveOrderTx.defaultExpectation == nil {
		mmSaveOrderTx.defaultExpectation = &StorageMockSaveOrderTxExpectation{mock: mmSaveOrderTx.mock}
	}
	mmSaveOrderTx.defaultExpectation.results = &StorageMockSaveOrderTxResults{err}
	mmSaveOrderTx.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSaveOrderTx.mock
}

// Set uses given function f to mock the Storage.SaveOrderTx method
func (mmSaveOrderTx *mStorageMockSaveOrderTx) Set(f func(ctx context.Context, tx pgx.Tx, order models.Order) (err error)) *StorageMock {
	if mmSaveOrderTx.defaultExpectation != nil {
		mmSaveOrderTx.mock.t.Fatalf("Default expectation is already set for the Storage.SaveOrderTx method")
	}

	if len(mmSaveOrderTx.expectations) > 0 {
		mmSaveOrderTx.mock.t.Fatalf("Some expectations are already set for the Storage.SaveOrderTx method")
	}

	mmSaveOrderTx.mock.funcSaveOrderTx = f
	mmSaveOrderTx.mock.funcSaveOrderTxOrigin = minimock.CallerInfo(1)
	return mmSaveOrderTx.mock
}

// When sets expectation for the Storage.SaveOrderTx which will trigger the result defined by the following
// Then helper
func (mmSaveOrderTx *mStorageMockSaveOrderTx) When(ctx context.Context, tx pgx.Tx, order models.Order) *StorageMockSaveOrderTxExpectation {
	if mmSaveOrderTx.mock.funcSaveOrderTx != nil {
		mmSaveOrderTx.mock.t.Fatalf("StorageMock.SaveOrderTx mock is already set by Set")
	}

	expectation := &StorageMockSaveOrderTxExpectation{
		mock:               mmSaveOrderTx.mock,
		params:             &StorageMockSaveOrderTxParams{ctx, tx, order},
		expectationOrigins: StorageMockSaveOrderTxExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSaveOrderTx.expectations = append(mmSaveOrderTx.expectations, expectation)
	return expectation
}

// Then sets up Storage.SaveOrderTx return parameters for the expectation previously defined by the When method
func (e *StorageMockSaveOrderTxExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockSaveOrderTxResults{err}
	return e.mock
}

// Times sets number of times Storage.SaveOrderTx should be invoked
func (mmSaveOrderTx *mStorageMockSaveOrderTx) Times(n uint64) *mStorageMockSaveOrderTx {
	if n == 0 {
		mmSaveOrderTx.mock.t.Fatalf("Times of StorageMock.SaveOrderTx mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSaveOrderTx.expectedInvocations, n)
	mmSaveOrderTx.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSaveOrderTx
}

func (mmSaveOrderTx *mStorageMockSaveOrderTx) invocationsDone() bool {
	if len(mmSaveOrderTx.expectations) == 0 && mmSaveOrderTx.defaultExpectation == nil && mmSaveOrderTx.mock.funcSaveOrderTx == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSaveOrderTx.mock.afterSaveOrderTxCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSaveOrderTx.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SaveOrderTx implements mm_storage.Storage
func (mmSaveOrderTx *StorageMock) SaveOrderTx(ctx context.Context, tx pgx.Tx, order models.Order) (err error) {
	mm_atomic.AddUint64(&mmSaveOrderTx.beforeSaveOrderTxCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveOrderTx.afterSaveOrderTxCounter, 1)

	mmSaveOrderTx.t.Helper()

	if mmSaveOrderTx.inspectFuncSaveOrderTx != nil {
		mmSaveOrderTx.inspectFuncSaveOrderTx(ctx, tx, order)
	}

	mm_params := StorageMockSaveOrderTxParams{ctx, tx, order}

	// Record call args
	mmSaveOrderTx.SaveOrderTxMock.mutex.Lock()
	mmSaveOrderTx.SaveOrderTxMock.callArgs = append(mmSaveOrderTx.SaveOrderTxMock.callArgs, &mm_params)
	mmSaveOrderTx.SaveOrderTxMock.mutex.Unlock()

	for _, e := range mmSaveOrderTx.SaveOrderTxMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSaveOrderTx.SaveOrderTxMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveOrderTx.SaveOrderTxMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveOrderTx.SaveOrderTxMock.defaultExpectation.params
		mm_want_ptrs := mmSaveOrderTx.SaveOrderTxMock.defaultExpectation.paramPtrs

		mm_got := StorageMockSaveOrderTxParams{ctx, tx, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSaveOrderTx.t.Errorf("StorageMock.SaveOrderTx got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveOrderTx.SaveOrderTxMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tx != nil && !minimock.Equal(*mm_want_ptrs.tx, mm_got.tx) {
				mmSaveOrderTx.t.Errorf("StorageMock.SaveOrderTx got unexpected parameter tx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveOrderTx.SaveOrderTxMock.defaultExpectation.expectationOrigins.originTx, *mm_want_ptrs.tx, mm_got.tx, minimock.Diff(*mm_want_ptrs.tx, mm_got.tx))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmSaveOrderTx.t.Errorf("StorageMock.SaveOrderTx got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveOrderTx.SaveOrderTxMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveOrderTx.t.Errorf("StorageMock.SaveOrderTx got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSaveOrderTx.SaveOrderTxMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveOrderTx.SaveOrderTxMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveOrderTx.t.Fatal("No results are set for the StorageMock.SaveOrderTx")
		}
		return (*mm_results).err
	}
	if mmSaveOrderTx.funcSaveOrderTx != nil {
		return mmSaveOrderTx.funcSaveOrderTx(ctx, tx, order)
	}
	mmSaveOrderTx.t.Fatalf("Unexpected call to StorageMock.SaveOrderTx. %v %v %v", ctx, tx, order)
	return
}

// SaveOrderTxAfterCounter returns a count of finished StorageMock.SaveOrderTx invocations
func (mmSaveOrderTx *StorageMock) SaveOrderTxAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveOrderTx.afterSaveOrderTxCounter)
}

// SaveOrderTxBeforeCounter returns a count of StorageMock.SaveOrderTx invocations
func (mmSaveOrderTx *StorageMock) SaveOrderTxBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveOrderTx.beforeSaveOrderTxCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.SaveOrderTx.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveOrderTx *mStorageMockSaveOrderTx) Calls() []*StorageMockSaveOrderTxParams {
	mmSaveOrderTx.mutex.RLock()

	argCopy := make([]*StorageMockSaveOrderTxParams, len(mmSaveOrderTx.callArgs))
	copy(argCopy, mmSaveOrderTx.callArgs)

	mmSaveOrderTx.mutex.RUnlock()

	return argCopy
}

// MinimockSaveOrderTxDone returns true if the count of the SaveOrderTx invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockSaveOrderTxDone() bool {
	if m.SaveOrderTxMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SaveOrderTxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SaveOrderTxMock.invocationsDone()
}

// MinimockSaveOrderTxInspect logs each unmet expectation
func (m *StorageMock) MinimockSaveOrderTxInspect() {
	for _, e := range m.SaveOrderTxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.SaveOrderTx at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSaveOrderTxCounter := mm_atomic.LoadUint64(&m.afterSaveOrderTxCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SaveOrderTxMock.defaultExpectation != nil && afterSaveOrderTxCounter < 1 {
		if m.SaveOrderTxMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.SaveOrderTx at\n%s", m.SaveOrderTxMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.SaveOrderTx at\n%s with params: %#v", m.SaveOrderTxMock.defaultExpectation.expectationOrigins.origin, *m.SaveOrderTxMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveOrderTx != nil && afterSaveOrderTxCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.SaveOrderTx at\n%s", m.funcSaveOrderTxOrigin)
	}

	if !m.SaveOrderTxMock.invocationsDone() && afterSaveOrderTxCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.SaveOrderTx at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SaveOrderTxMock.expectedInvocations), m.SaveOrderTxMock.expectedInvocationsOrigin, afterSaveOrderTxCounter)
	}
}

type mStorageMockUpdateOrderTx struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockUpdateOrderTxExpectation
	expectations       []*StorageMockUpdateOrderTxExpectation

	callArgs []*StorageMockUpdateOrderTxParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockUpdateOrderTxExpectation specifies expectation struct of the Storage.UpdateOrderTx
type StorageMockUpdateOrderTxExpectation struct {
	mock               *StorageMock
	params             *StorageMockUpdateOrderTxParams
	paramPtrs          *StorageMockUpdateOrderTxParamPtrs
	expectationOrigins StorageMockUpdateOrderTxExpectationOrigins
	results            *StorageMockUpdateOrderTxResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockUpdateOrderTxParams contains parameters of the Storage.UpdateOrderTx
type StorageMockUpdateOrderTxParams struct {
	ctx   context.Context
	tx    pgx.Tx
	order models.Order
}

// StorageMockUpdateOrderTxParamPtrs contains pointers to parameters of the Storage.UpdateOrderTx
type StorageMockUpdateOrderTxParamPtrs struct {
	ctx   *context.Context
	tx    *pgx.Tx
	order *models.Order
}

// StorageMockUpdateOrderTxResults contains results of the Storage.UpdateOrderTx
type StorageMockUpdateOrderTxResults struct {
	err error
}

// StorageMockUpdateOrderTxOrigins contains origins of expectations of the Storage.UpdateOrderTx
type StorageMockUpdateOrderTxExpectationOrigins struct {
	origin      string
	originCtx   string
	originTx    string
	originOrder string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateOrderTx *mStorageMockUpdateOrderTx) Optional() *mStorageMockUpdateOrderTx {
	mmUpdateOrderTx.optional = true
	return mmUpdateOrderTx
}

// Expect sets up expected params for Storage.UpdateOrderTx
func (mmUpdateOrderTx *mStorageMockUpdateOrderTx) Expect(ctx context.Context, tx pgx.Tx, order models.Order) *mStorageMockUpdateOrderTx {
	if mmUpdateOrderTx.mock.funcUpdateOrderTx != nil {
		mmUpdateOrderTx.mock.t.Fatalf("StorageMock.UpdateOrderTx mock is already set by Set")
	}

	if mmUpdateOrderTx.defaultExpectation == nil {
		mmUpdateOrderTx.defaultExpectation = &StorageMockUpdateOrderTxExpectation{}
	}

	if mmUpdateOrderTx.defaultExpectation.paramPtrs != nil {
		mmUpdateOrderTx.mock.t.Fatalf("StorageMock.UpdateOrderTx mock is already set by ExpectParams functions")
	}

	mmUpdateOrderTx.defaultExpectation.params = &StorageMockUpdateOrderTxParams{ctx, tx, order}
	mmUpdateOrderTx.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateOrderTx.expectations {
		if minimock.Equal(e.params, mmUpdateOrderTx.defaultExpectation.params) {
			mmUpdateOrderTx.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateOrderTx.defaultExpectation.params)
		}
	}

	return mmUpdateOrderTx
}

// ExpectCtxParam1 sets up expected param ctx for Storage.UpdateOrderTx
func (mmUpdateOrderTx *mStorageMockUpdateOrderTx) ExpectCtxParam1(ctx context.Context) *mStorageMockUpdateOrderTx {
	if mmUpdateOrderTx.mock.funcUpdateOrderTx != nil {
		mmUpdateOrderTx.mock.t.Fatalf("StorageMock.UpdateOrderTx mock is already set by Set")
	}

	if mmUpdateOrderTx.defaultExpectation == nil {
		mmUpdateOrderTx.defaultExpectation = &StorageMockUpdateOrderTxExpectation{}
	}

	if mmUpdateOrderTx.defaultExpectation.params != nil {
		mmUpdateOrderTx.mock.t.Fatalf("StorageMock.UpdateOrderTx mock is already set by Expect")
	}

	if mmUpdateOrderTx.defaultExpectation.paramPtrs == nil {
		mmUpdateOrderTx.defaultExpectation.paramPtrs = &StorageMockUpdateOrderTxParamPtrs{}
	}
	mmUpdateOrderTx.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateOrderTx.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateOrderTx
}

// ExpectTxParam2 sets up expected param tx for Storage.UpdateOrderTx
func (mmUpdateOrderTx *mStorageMockUpdateOrderTx) ExpectTxParam2(tx pgx.Tx) *mStorageMockUpdateOrderTx {
	if mmUpdateOrderTx.mock.funcUpdateOrderTx != nil {
		mmUpdateOrderTx.mock.t.Fatalf("StorageMock.UpdateOrderTx mock is already set by Set")
	}

	if mmUpdateOrderTx.defaultExpectation == nil {
		mmUpdateOrderTx.defaultExpectation = &StorageMockUpdateOrderTxExpectation{}
	}

	if mmUpdateOrderTx.defaultExpectation.params != nil {
		mmUpdateOrderTx.mock.t.Fatalf("StorageMock.UpdateOrderTx mock is already set by Expect")
	}

	if mmUpdateOrderTx.defaultExpectation.paramPtrs == nil {
		mmUpdateOrderTx.defaultExpectation.paramPtrs = &StorageMockUpdateOrderTxParamPtrs{}
	}
	mmUpdateOrderTx.defaultExpectation.paramPtrs.tx = &tx
	mmUpdateOrderTx.defaultExpectation.expectationOrigins.originTx = minimock.CallerInfo(1)

	return mmUpdateOrderTx
}

// ExpectOrderParam3 sets up expected param order for Storage.UpdateOrderTx
func (mmUpdateOrderTx *mStorageMockUpdateOrderTx) ExpectOrderParam3(order models.Order) *mStorageMockUpdateOrderTx {
	if mmUpdateOrderTx.mock.funcUpdateOrderTx != nil {
		mmUpdateOrderTx.mock.t.Fatalf("StorageMock.UpdateOrderTx mock is already set by Set")
	}

	if mmUpdateOrderTx.defaultExpectation == nil {
		mmUpdateOrderTx.defaultExpectation = &StorageMockUpdateOrderTxExpectation{}
	}

	if mmUpdateOrderTx.defaultExpectation.params != nil {
		mmUpdateOrderTx.mock.t.Fatalf("StorageMock.UpdateOrderTx mock is already set by Expect")
	}

	if mmUpdateOrderTx.defaultExpectation.paramPtrs == nil {
		mmUpdateOrderTx.defaultExpectation.paramPtrs = &StorageMockUpdateOrderTxParamPtrs{}
	}
	mmUpdateOrderTx.defaultExpectation.paramPtrs.order = &order
	mmUpdateOrderTx.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmUpdateOrderTx
}

// Inspect accepts an inspector function that has same arguments as the Storage.UpdateOrderTx
func (mmUpdateOrderTx *mStorageMockUpdateOrderTx) Inspect(f func(ctx context.Context, tx pgx.Tx, order models.Order)) *mStorageMockUpdateOrderTx {
	if mmUpdateOrderTx.mock.inspectFuncUpdateOrderTx != nil {
		mmUpdateOrderTx.mock.t.Fatalf("Inspect function is already set for StorageMock.UpdateOrderTx")
	}

	mmUpdateOrderTx.mock.inspectFuncUpdateOrderTx = f

	return mmUpdateOrderTx
}

// Return sets up results that will be returned by Storage.UpdateOrderTx
func (mmUpdateOrderTx *mStorageMockUpdateOrderTx) Return(err error) *StorageMock {
	if mmUpdateOrderTx.mock.funcUpdateOrderTx != nil {
		mmUpdateOrderTx.mock.t.Fatalf("StorageMock.UpdateOrderTx mock is already set by Set")
	}

	if mmUpdateOrderTx.defaultExpectation == nil {
		mmUpdateOrderTx.defaultExpectation = &StorageMockUpdateOrderTxExpectation{mock: mmUpdateOrderTx.mock}
	}
	mmUpdateOrderTx.defaultExpectation.results = &StorageMockUpdateOrderTxResults{err}
	mmUpdateOrderTx.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateOrderTx.mock
}

// Set uses given function f to mock the Storage.UpdateOrderTx method
func (mmUpdateOrderTx *mStorageMockUpdateOrderTx) Set(f func(ctx context.Context, tx pgx.Tx, order models.Order) (err error)) *StorageMock {
	if mmUpdateOrderTx.defaultExpectation != nil {
		mmUpdateOrderTx.mock.t.Fatalf("Default expectation is already set for the Storage.UpdateOrderTx method")
	}

	if len(mmUpdateOrderTx.expectations) > 0 {
		mmUpdateOrderTx.mock.t.Fatalf("Some expectations are already set for the Storage.UpdateOrderTx method")
	}

	mmUpdateOrderTx.mock.funcUpdateOrderTx = f
	mmUpdateOrderTx.mock.funcUpdateOrderTxOrigin = minimock.CallerInfo(1)
	return mmUpdateOrderTx.mock
}

// When sets expectation for the Storage.UpdateOrderTx which will trigger the result defined by the following
// Then helper
func (mmUpdateOrderTx *mStorageMockUpdateOrderTx) When(ctx context.Context, tx pgx.Tx, order models.Order) *StorageMockUpdateOrderTxExpectation {
	if mmUpdateOrderTx.mock.funcUpdateOrderTx != nil {
		mmUpdateOrderTx.mock.t.Fatalf("StorageMock.UpdateOrderTx mock is already set by Set")
	}

	expectation := &StorageMockUpdateOrderTxExpectation{
		mock:               mmUpdateOrderTx.mock,
		params:             &StorageMockUpdateOrderTxParams{ctx, tx, order},
		expectationOrigins: StorageMockUpdateOrderTxExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateOrderTx.expectations = append(mmUpdateOrderTx.expectations, expectation)
	return expectation
}

// Then sets up Storage.UpdateOrderTx return parameters for the expectation previously defined by the When method
func (e *StorageMockUpdateOrderTxExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockUpdateOrderTxResults{err}
	return e.mock
}

// Times sets number of times Storage.UpdateOrderTx should be invoked
func (mmUpdateOrderTx *mStorageMockUpdateOrderTx) Times(n uint64) *mStorageMockUpdateOrderTx {
	if n == 0 {
		mmUpdateOrderTx.mock.t.Fatalf("Times of StorageMock.UpdateOrderTx mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateOrderTx.expectedInvocations, n)
	mmUpdateOrderTx.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateOrderTx
}

func (mmUpdateOrderTx *mStorageMockUpdateOrderTx) invocationsDone() bool {
	if len(mmUpdateOrderTx.expectations) == 0 && mmUpdateOrderTx.defaultExpectation == nil && mmUpdateOrderTx.mock.funcUpdateOrderTx == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateOrderTx.mock.afterUpdateOrderTxCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateOrderTx.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateOrderTx implements mm_storage.Storage
func (mmUpdateOrderTx *StorageMock) UpdateOrderTx(ctx context.Context, tx pgx.Tx, order models.Order) (err error) {
	mm_atomic.AddUint64(&mmUpdateOrderTx.beforeUpdateOrderTxCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateOrderTx.afterUpdateOrderTxCounter, 1)

	mmUpdateOrderTx.t.Helper()

	if mmUpdateOrderTx.inspectFuncUpdateOrderTx != nil {
		mmUpdateOrderTx.inspectFuncUpdateOrderTx(ctx, tx, order)
	}

	mm_params := StorageMockUpdateOrderTxParams{ctx, tx, order}

	// Record call args
	mmUpdateOrderTx.UpdateOrderTxMock.mutex.Lock()
	mmUpdateOrderTx.UpdateOrderTxMock.callArgs = append(mmUpdateOrderTx.UpdateOrderTxMock.callArgs, &mm_params)
	mmUpdateOrderTx.UpdateOrderTxMock.mutex.Unlock()

	for _, e := range mmUpdateOrderTx.UpdateOrderTxMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateOrderTx.UpdateOrderTxMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateOrderTx.UpdateOrderTxMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateOrderTx.UpdateOrderTxMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateOrderTx.UpdateOrderTxMock.defaultExpectation.paramPtrs

		mm_got := StorageMockUpdateOrderTxParams{ctx, tx, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateOrderTx.t.Errorf("StorageMock.UpdateOrderTx got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateOrderTx.UpdateOrderTxMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tx != nil && !minimock.Equal(*mm_want_ptrs.tx, mm_got.tx) {
				mmUpdateOrderTx.t.Errorf("StorageMock.UpdateOrderTx got unexpected parameter tx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateOrderTx.UpdateOrderTxMock.defaultExpectation.expectationOrigins.originTx, *mm_want_ptrs.tx, mm_got.tx, minimock.Diff(*mm_want_ptrs.tx, mm_got.tx))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmUpdateOrderTx.t.Errorf("StorageMock.UpdateOrderTx got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateOrderTx.UpdateOrderTxMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateOrderTx.t.Errorf("StorageMock.UpdateOrderTx got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateOrderTx.UpdateOrderTxMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateOrderTx.UpdateOrderTxMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateOrderTx.t.Fatal("No results are set for the StorageMock.UpdateOrderTx")
		}
		return (*mm_results).err
	}
	if mmUpdateOrderTx.funcUpdateOrderTx != nil {
		return mmUpdateOrderTx.funcUpdateOrderTx(ctx, tx, order)
	}
	mmUpdateOrderTx.t.Fatalf("Unexpected call to StorageMock.UpdateOrderTx. %v %v %v", ctx, tx, order)
	return
}

// UpdateOrderTxAfterCounter returns a count of finished StorageMock.UpdateOrderTx invocations
func (mmUpdateOrderTx *StorageMock) UpdateOrderTxAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrderTx.afterUpdateOrderTxCounter)
}

// UpdateOrderTxBeforeCounter returns a count of StorageMock.UpdateOrderTx invocations
func (mmUpdateOrderTx *StorageMock) UpdateOrderTxBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrderTx.beforeUpdateOrderTxCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.UpdateOrderTx.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateOrderTx *mStorageMockUpdateOrderTx) Calls() []*StorageMockUpdateOrderTxParams {
	mmUpdateOrderTx.mutex.RLock()

	argCopy := make([]*StorageMockUpdateOrderTxParams, len(mmUpdateOrderTx.callArgs))
	copy(argCopy, mmUpdateOrderTx.callArgs)

	mmUpdateOrderTx.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateOrderTxDone returns true if the count of the UpdateOrderTx invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockUpdateOrderTxDone() bool {
	if m.UpdateOrderTxMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateOrderTxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateOrderTxMock.invocationsDone()
}

// MinimockUpdateOrderTxInspect logs each unmet expectation
func (m *StorageMock) MinimockUpdateOrderTxInspect() {
	for _, e := range m.UpdateOrderTxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.UpdateOrderTx at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateOrderTxCounter := mm_atomic.LoadUint64(&m.afterUpdateOrderTxCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrderTxMock.defaultExpectation != nil && afterUpdateOrderTxCounter < 1 {
		if m.UpdateOrderTxMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.UpdateOrderTx at\n%s", m.UpdateOrderTxMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.UpdateOrderTx at\n%s with params: %#v", m.UpdateOrderTxMock.defaultExpectation.expectationOrigins.origin, *m.UpdateOrderTxMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrderTx != nil && afterUpdateOrderTxCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.UpdateOrderTx at\n%s", m.funcUpdateOrderTxOrigin)
	}

	if !m.UpdateOrderTxMock.invocationsDone() && afterUpdateOrderTxCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.UpdateOrderTx at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateOrderTxMock.expectedInvocations), m.UpdateOrderTxMock.expectedInvocationsOrigin, afterUpdateOrderTxCounter)
	}
}

type mStorageMockWithTransaction struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockWithTransactionExpectation
	expectations       []*StorageMockWithTransactionExpectation

	callArgs []*StorageMockWithTransactionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockWithTransactionExpectation specifies expectation struct of the Storage.WithTransaction
type StorageMockWithTransactionExpectation struct {
	mock               *StorageMock
	params             *StorageMockWithTransactionParams
	paramPtrs          *StorageMockWithTransactionParamPtrs
	expectationOrigins StorageMockWithTransactionExpectationOrigins
	results            *StorageMockWithTransactionResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockWithTransactionParams contains parameters of the Storage.WithTransaction
type StorageMockWithTransactionParams struct {
	ctx context.Context
	fn  func(ctx context.Context, tx pgx.Tx) error
}

// StorageMockWithTransactionParamPtrs contains pointers to parameters of the Storage.WithTransaction
type StorageMockWithTransactionParamPtrs struct {
	ctx *context.Context
	fn  *func(ctx context.Context, tx pgx.Tx) error
}

// StorageMockWithTransactionResults contains results of the Storage.WithTransaction
type StorageMockWithTransactionResults struct {
	err error
}

// StorageMockWithTransactionOrigins contains origins of expectations of the Storage.WithTransaction
type StorageMockWithTransactionExpectationOrigins struct {
	origin    string
	originCtx string
	originFn  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWithTransaction *mStorageMockWithTransaction) Optional() *mStorageMockWithTransaction {
	mmWithTransaction.optional = true
	return mmWithTransaction
}

// Expect sets up expected params for Storage.WithTransaction
func (mmWithTransaction *mStorageMockWithTransaction) Expect(ctx context.Context, fn func(ctx context.Context, tx pgx.Tx) error) *mStorageMockWithTransaction {
	if mmWithTransaction.mock.funcWithTransaction != nil {
		mmWithTransaction.mock.t.Fatalf("StorageMock.WithTransaction mock is already set by Set")
	}

	if mmWithTransaction.defaultExpectation == nil {
		mmWithTransaction.defaultExpectation = &StorageMockWithTransactionExpectation{}
	}

	if mmWithTransaction.defaultExpectation.paramPtrs != nil {
		mmWithTransaction.mock.t.Fatalf("StorageMock.WithTransaction mock is already set by ExpectParams functions")
	}

	mmWithTransaction.defaultExpectation.params = &StorageMockWithTransactionParams{ctx, fn}
	mmWithTransaction.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWithTransaction.expectations {
		if minimock.Equal(e.params, mmWithTransaction.defaultExpectation.params) {
			mmWithTransaction.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithTransaction.defaultExpectation.params)
		}
	}

	return mmWithTransaction
}

// ExpectCtxParam1 sets up expected param ctx for Storage.WithTransaction
func (mmWithTransaction *mStorageMockWithTransaction) ExpectCtxParam1(ctx context.Context) *mStorageMockWithTransaction {
	if mmWithTransaction.mock.funcWithTransaction != nil {
		mmWithTransaction.mock.t.Fatalf("StorageMock.WithTransaction mock is already set by Set")
	}

	if mmWithTransaction.defaultExpectation == nil {
		mmWithTransaction.defaultExpectation = &StorageMockWithTransactionExpectation{}
	}

	if mmWithTransaction.defaultExpectation.params != nil {
		mmWithTransaction.mock.t.Fatalf("StorageMock.WithTransaction mock is already set by Expect")
	}

	if mmWithTransaction.defaultExpectation.paramPtrs == nil {
		mmWithTransaction.defaultExpectation.paramPtrs = &StorageMockWithTransactionParamPtrs{}
	}
	mmWithTransaction.defaultExpectation.paramPtrs.ctx = &ctx
	mmWithTransaction.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmWithTransaction
}

// ExpectFnParam2 sets up expected param fn for Storage.WithTransaction
func (mmWithTransaction *mStorageMockWithTransaction) ExpectFnParam2(fn func(ctx context.Context, tx pgx.Tx) error) *mStorageMockWithTransaction {
	if mmWithTransaction.mock.funcWithTransaction != nil {
		mmWithTransaction.mock.t.Fatalf("StorageMock.WithTransaction mock is already set by Set")
	}

	if mmWithTransaction.defaultExpectation == nil {
		mmWithTransaction.defaultExpectation = &StorageMockWithTransactionExpectation{}
	}

	if mmWithTransaction.defaultExpectation.params != nil {
		mmWithTransaction.mock.t.Fatalf("StorageMock.WithTransaction mock is already set by Expect")
	}

	if mmWithTransaction.defaultExpectation.paramPtrs == nil {
		mmWithTransaction.defaultExpectation.paramPtrs = &StorageMockWithTransactionParamPtrs{}
	}
	mmWithTransaction.defaultExpectation.paramPtrs.fn = &fn
	mmWithTransaction.defaultExpectation.expectationOrigins.originFn = minimock.CallerInfo(1)

	return mmWithTransaction
}

// Inspect accepts an inspector function that has same arguments as the Storage.WithTransaction
func (mmWithTransaction *mStorageMockWithTransaction) Inspect(f func(ctx context.Context, fn func(ctx context.Context, tx pgx.Tx) error)) *mStorageMockWithTransaction {
	if mmWithTransaction.mock.inspectFuncWithTransaction != nil {
		mmWithTransaction.mock.t.Fatalf("Inspect function is already set for StorageMock.WithTransaction")
	}

	mmWithTransaction.mock.inspectFuncWithTransaction = f

	return mmWithTransaction
}

// Return sets up results that will be returned by Storage.WithTransaction
func (mmWithTransaction *mStorageMockWithTransaction) Return(err error) *StorageMock {
	if mmWithTransaction.mock.funcWithTransaction != nil {
		mmWithTransaction.mock.t.Fatalf("StorageMock.WithTransaction mock is already set by Set")
	}

	if mmWithTransaction.defaultExpectation == nil {
		mmWithTransaction.defaultExpectation = &StorageMockWithTransactionExpectation{mock: mmWithTransaction.mock}
	}
	mmWithTransaction.defaultExpectation.results = &StorageMockWithTransactionResults{err}
	mmWithTransaction.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWithTransaction.mock
}

// Set uses given function f to mock the Storage.WithTransaction method
func (mmWithTransaction *mStorageMockWithTransaction) Set(f func(ctx context.Context, fn func(ctx context.Context, tx pgx.Tx) error) (err error)) *StorageMock {
	if mmWithTransaction.defaultExpectation != nil {
		mmWithTransaction.mock.t.Fatalf("Default expectation is already set for the Storage.WithTransaction method")
	}

	if len(mmWithTransaction.expectations) > 0 {
		mmWithTransaction.mock.t.Fatalf("Some expectations are already set for the Storage.WithTransaction method")
	}

	mmWithTransaction.mock.funcWithTransaction = f
	mmWithTransaction.mock.funcWithTransactionOrigin = minimock.CallerInfo(1)
	return mmWithTransaction.mock
}

// When sets expectation for the Storage.WithTransaction which will trigger the result defined by the following
// Then helper
func (mmWithTransaction *mStorageMockWithTransaction) When(ctx context.Context, fn func(ctx context.Context, tx pgx.Tx) error) *StorageMockWithTransactionExpectation {
	if mmWithTransaction.mock.funcWithTransaction != nil {
		mmWithTransaction.mock.t.Fatalf("StorageMock.WithTransaction mock is already set by Set")
	}

	expectation := &StorageMockWithTransactionExpectation{
		mock:               mmWithTransaction.mock,
		params:             &StorageMockWithTransactionParams{ctx, fn},
		expectationOrigins: StorageMockWithTransactionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWithTransaction.expectations = append(mmWithTransaction.expectations, expectation)
	return expectation
}

// Then sets up Storage.WithTransaction return parameters for the expectation previously defined by the When method
func (e *StorageMockWithTransactionExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockWithTransactionResults{err}
	return e.mock
}

// Times sets number of times Storage.WithTransaction should be invoked
func (mmWithTransaction *mStorageMockWithTransaction) Times(n uint64) *mStorageMockWithTransaction {
	if n == 0 {
		mmWithTransaction.mock.t.Fatalf("Times of StorageMock.WithTransaction mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWithTransaction.expectedInvocations, n)
	mmWithTransaction.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWithTransaction
}

func (mmWithTransaction *mStorageMockWithTransaction) invocationsDone() bool {
	if len(mmWithTransaction.expectations) == 0 && mmWithTransaction.defaultExpectation == nil && mmWithTransaction.mock.funcWithTransaction == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWithTransaction.mock.afterWithTransactionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWithTransaction.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WithTransaction implements mm_storage.Storage
func (mmWithTransaction *StorageMock) WithTransaction(ctx context.Context, fn func(ctx context.Context, tx pgx.Tx) error) (err error) {
	mm_atomic.AddUint64(&mmWithTransaction.beforeWithTransactionCounter, 1)
	defer mm_atomic.AddUint64(&mmWithTransaction.afterWithTransactionCounter, 1)

	mmWithTransaction.t.Helper()

	if mmWithTransaction.inspectFuncWithTransaction != nil {
		mmWithTransaction.inspectFuncWithTransaction(ctx, fn)
	}

	mm_params := StorageMockWithTransactionParams{ctx, fn}

	// Record call args
	mmWithTransaction.WithTransactionMock.mutex.Lock()
	mmWithTransaction.WithTransactionMock.callArgs = append(mmWithTransaction.WithTransactionMock.callArgs, &mm_params)
	mmWithTransaction.WithTransactionMock.mutex.Unlock()

	for _, e := range mmWithTransaction.WithTransactionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmWithTransaction.WithTransactionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithTransaction.WithTransactionMock.defaultExpectation.Counter, 1)
		mm_want := mmWithTransaction.WithTransactionMock.defaultExpectation.params
		mm_want_ptrs := mmWithTransaction.WithTransactionMock.defaultExpectation.paramPtrs

		mm_got := StorageMockWithTransactionParams{ctx, fn}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmWithTransaction.t.Errorf("StorageMock.WithTransaction got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWithTransaction.WithTransactionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fn != nil && !minimock.Equal(*mm_want_ptrs.fn, mm_got.fn) {
				mmWithTransaction.t.Errorf("StorageMock.WithTransaction got unexpected parameter fn, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWithTransaction.WithTransactionMock.defaultExpectation.expectationOrigins.originFn, *mm_want_ptrs.fn, mm_got.fn, minimock.Diff(*mm_want_ptrs.fn, mm_got.fn))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWithTransaction.t.Errorf("StorageMock.WithTransaction got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWithTransaction.WithTransactionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWithTransaction.WithTransactionMock.defaultExpectation.results
		if mm_results == nil {
			mmWithTransaction.t.Fatal("No results are set for the StorageMock.WithTransaction")
		}
		return (*mm_results).err
	}
	if mmWithTransaction.funcWithTransaction != nil {
		return mmWithTransaction.funcWithTransaction(ctx, fn)
	}
	mmWithTransaction.t.Fatalf("Unexpected call to StorageMock.WithTransaction. %v %v", ctx, fn)
	return
}

// WithTransactionAfterCounter returns a count of finished StorageMock.WithTransaction invocations
func (mmWithTransaction *StorageMock) WithTransactionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithTransaction.afterWithTransactionCounter)
}

// WithTransactionBeforeCounter returns a count of StorageMock.WithTransaction invocations
func (mmWithTransaction *StorageMock) WithTransactionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithTransaction.beforeWithTransactionCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.WithTransaction.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithTransaction *mStorageMockWithTransaction) Calls() []*StorageMockWithTransactionParams {
	mmWithTransaction.mutex.RLock()

	argCopy := make([]*StorageMockWithTransactionParams, len(mmWithTransaction.callArgs))
	copy(argCopy, mmWithTransaction.callArgs)

	mmWithTransaction.mutex.RUnlock()

	return argCopy
}

// MinimockWithTransactionDone returns true if the count of the WithTransaction invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockWithTransactionDone() bool {
	if m.WithTransactionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WithTransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WithTransactionMock.invocationsDone()
}

// MinimockWithTransactionInspect logs each unmet expectation
func (m *StorageMock) MinimockWithTransactionInspect() {
	for _, e := range m.WithTransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.WithTransaction at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWithTransactionCounter := mm_atomic.LoadUint64(&m.afterWithTransactionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WithTransactionMock.defaultExpectation != nil && afterWithTransactionCounter < 1 {
		if m.WithTransactionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.WithTransaction at\n%s", m.WithTransactionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.WithTransaction at\n%s with params: %#v", m.WithTransactionMock.defaultExpectation.expectationOrigins.origin, *m.WithTransactionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithTransaction != nil && afterWithTransactionCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.WithTransaction at\n%s", m.funcWithTransactionOrigin)
	}

	if !m.WithTransactionMock.invocationsDone() && afterWithTransactionCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.WithTransaction at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WithTransactionMock.expectedInvocations), m.WithTransactionMock.expectedInvocationsOrigin, afterWithTransactionCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StorageMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDeleteOrderInspect()

			m.MinimockGetHistoryInspect()

			m.MinimockGetOrderInspect()

			m.MinimockListOrdersInspect()

			m.MinimockSaveOrderTxInspect()

			m.MinimockUpdateOrderTxInspect()

			m.MinimockWithTransactionInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDeleteOrderDone() &&
		m.MinimockGetHistoryDone() &&
		m.MinimockGetOrderDone() &&
		m.MinimockListOrdersDone() &&
		m.MinimockSaveOrderTxDone() &&
		m.MinimockUpdateOrderTxDone() &&
		m.MinimockWithTransactionDone()
}
